<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control de Mouse con Mano</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: white;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #video {
            display: none;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            padding: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 0 0 10px 0;
            z-index: 100;
        }
        #status {
            margin-top: 10px;
            color: #4CAF50;
            font-weight: bold;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        #cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
            z-index: 90;
            display: none;
        }
        #click-effect {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(76, 175, 80, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 80;
            display: none;
            transform: scale(0);
            transition: transform 0.3s;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="cursor"></div>
        <div id="click-effect"></div>
        
        <div id="ui">
            <h2>Control de Mouse con Mano</h2>
            <p>Instrucciones:</p>
            <ol>
                <li>Haz clic en "Iniciar" y permite el acceso a la cámara</li>
                <li>Muestra tu mano a la cámara</li>
                <li>Usa el dedo índice para mover el cursor</li>
                <li>Junta índice y pulgar para hacer clic</li>
            </ol>
            <button id="start-btn">Iniciar</button>
            <div id="status">Esperando inicio...</div>
        </div>
    </div>

    <script>
        // Elementos del DOM
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start-btn');
        const statusDiv = document.getElementById('status');
        const cursor = document.getElementById('cursor');
        const clickEffect = document.getElementById('click-effect');
        
        // Configuración
        let model = null;
        let isRunning = false;
        let animationFrameId = null;
        
        // Estado de la aplicación
        const appState = {
            clickCooldown: 0,
            clickDistanceThreshold: 0.08,
            smoothingFactor: 0.5,
            lastPosition: { x: 0.5, y: 0.5 },
            isClicking: false
        };
        
        // Inicialización
        async function init() {
            try {
                // Configurar canvas
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // Configurar botón
                startBtn.addEventListener('click', startApp);
                
                // Precargar TF.js para mejor performance
                await tf.ready();
                statusDiv.textContent = 'TensorFlow.js cargado';
                
            } catch (error) {
                handleError(error);
            }
        }
        
        // Iniciar la aplicación
        async function startApp() {
            try {
                startBtn.disabled = true;
                statusDiv.textContent = 'Iniciando cámara...';
                
                // Configurar cámara
                await setupCamera();
                await video.play();
                
                statusDiv.textContent = 'Cargando modelo de detección de manos...';
                
                // Cargar modelo
                model = await handPoseDetection.createDetector(
                    handPoseDetection.SupportedModels.MediaPipeHands, {
                        runtime: 'tfjs',
                        modelType: 'full',
                        maxHands: 1
                    });
                
                statusDiv.textContent = 'Listo! Muestra tu mano a la cámara';
                isRunning = true;
                cursor.style.display = 'block';
                
                // Iniciar detección
                detectHands();
                
            } catch (error) {
                handleError(error);
                startBtn.disabled = false;
            }
        }
        
        // Configurar cámara
        async function setupCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('API de cámara no disponible');
            }
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'user',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            
            video.srcObject = stream;
            
            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    resolve(video);
                };
            });
        }
        
        // Función principal de detección
        async function detectHands() {
            if (!isRunning) return;
            
            try {
                // Obtener predicciones
                const predictions = await model.estimateHands(video);
                
                // Limpiar canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Dibujar video en canvas
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
                ctx.restore();
                
                // Procesar manos detectadas
                if (predictions.length > 0) {
                    const hand = predictions[0];
                    processHand(hand);
                } else {
                    cursor.style.display = 'none';
                }
                
                // Actualizar cooldown de clic
                if (appState.clickCooldown > 0) {
                    appState.clickCooldown--;
                }
                
                // Continuar el bucle
                animationFrameId = requestAnimationFrame(detectHands);
                
            } catch (error) {
                handleError(error);
                stopApp();
            }
        }
        
        // Procesar una mano detectada
        function processHand(hand) {
            const landmarks = hand.keypoints;
            
            // Obtener puntos clave
            const indexTip = landmarks.find(p => p.name === 'index_finger_tip');
            const thumbTip = landmarks.find(p => p.name === 'thumb_tip');
            
            // Normalizar coordenadas (espejo porque la cámara está invertida)
            const normalizedLandmarks = normalizeLandmarks(landmarks, video.videoWidth, video.videoHeight);
            
            // Dibujar mano
            drawHand(normalizedLandmarks);
            
            // Controlar cursor si se detecta dedo índice
            if (indexTip) {
                controlCursor(indexTip, thumbTip);
            }
        }
        
        // Normalizar landmarks (0-1) y ajustar espejo
        function normalizeLandmarks(landmarks, width, height) {
            return landmarks.map(point => ({
                ...point,
                x: 1 - (point.x / width),
                y: point.y / height
            }));
        }
        
        // Dibujar mano en canvas
        function drawHand(landmarks) {
            // Dibujar conexiones
            const connections = [
                [0, 1], [0, 5], [0, 9], [0, 13], [0, 17], // Palma
                [1, 2], [2, 3], [3, 4], // Pulgar
                [5, 6], [6, 7], [7, 8], // Índice
                [9, 10], [10, 11], [11, 12], // Medio
                [13, 14], [14, 15], [15, 16], // Anular
                [17, 18], [18, 19], [19, 20] // Meñique
            ];
            
            ctx.strokeStyle = 'cyan';
            ctx.lineWidth = 2;
            
            connections.forEach(([i, j]) => {
                const a = landmarks[i];
                const b = landmarks[j];
                
                if (a && b) {
                    ctx.beginPath();
                    ctx.moveTo(a.x * canvas.width, a.y * canvas.height);
                    ctx.lineTo(b.x * canvas.width, b.y * canvas.height);
                    ctx.stroke();
                }
            });
            
            // Dibujar puntos clave
            ctx.fillStyle = 'red';
            landmarks.forEach(point => {
                if (point.name && (point.name.includes('index') || point.name.includes('thumb'))) {
                    ctx.beginPath();
                    ctx.arc(
                        point.x * canvas.width,
                        point.y * canvas.height,
                        5, 0, 2 * Math.PI
                    );
                    ctx.fill();
                }
            });
        }
        
        // Controlar cursor
        function controlCursor(indexTip, thumbTip) {
            // Suavizar movimiento
            const smoothedPos = getSmoothedPosition(indexTip.x, indexTip.y);
            
            // Mover cursor visual
            const cursorX = smoothedPos.x * window.innerWidth;
            const cursorY = smoothedPos.y * window.innerHeight;
            
            cursor.style.left = `${cursorX - 10}px`;
            cursor.style.top = `${cursorY - 10}px`;
            cursor.style.display = 'block';
            
            // Detectar clic
            if (thumbTip && appState.clickCooldown === 0) {
                const isClicking = isClickGesture(indexTip, thumbTip);
                
                if (isClicking && !appState.isClicking) {
                    // Mostrar efecto de clic
                    showClickEffect(cursorX, cursorY);
                    appState.clickCooldown = 10;
                    
                    // Aquí iría el código para simular clic real
                    console.log('CLIC!');
                }
                
                appState.isClicking = isClicking;
            }
        }
        
        // Suavizar posición
        function getSmoothedPosition(newX, newY) {
            appState.lastPosition = {
                x: appState.lastPosition.x * appState.smoothingFactor + newX * (1 - appState.smoothingFactor),
                y: appState.lastPosition.y * appState.smoothingFactor + newY * (1 - appState.smoothingFactor)
            };
            return appState.lastPosition;
        }
        
        // Detectar gesto de clic
        function isClickGesture(indexTip, thumbTip) {
            const distance = Math.hypot(
                indexTip.x - thumbTip.x,
                indexTip.y - thumbTip.y
            );
            return distance < appState.clickDistanceThreshold;
        }
        
        // Mostrar efecto visual de clic
        function showClickEffect(x, y) {
            clickEffect.style.left = `${x - 15}px`;
            clickEffect.style.top = `${y - 15}px`;
            clickEffect.style.display = 'block';
            
            setTimeout(() => {
                clickEffect.style.transform = 'scale(2)';
                clickEffect.style.opacity = '0';
                
                setTimeout(() => {
                    clickEffect.style.transform = 'scale(0)';
                    clickEffect.style.opacity = '1';
                    clickEffect.style.display = 'none';
                }, 300);
            }, 10);
        }
        
        // Ajustar tamaño del canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Detener aplicación
        function stopApp() {
            isRunning = false;
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            if (model) {
                model.dispose();
                model = null;
            }
            
            cursor.style.display = 'none';
            startBtn.disabled = false;
        }
        
        // Manejar errores
        function handleError(error) {
            console.error('Error:', error);
            statusDiv.textContent = `Error: ${error.message}`;
            statusDiv.style.color = '#f44336';
        }
        
        // Limpieza al salir
        window.addEventListener('beforeunload', stopApp);
        
        // Iniciar la aplicación
        init();
    </script>
</body>
</html>
